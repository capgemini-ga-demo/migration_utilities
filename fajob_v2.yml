name: Build and Push Docker Image

# Trigger the workflow on push to the main branch (or adjust based on your preference)
on:
  push:
    branches:
      - main

env:
  BASE_IMAGE: my-base-image  # Define your base image name
  BASE_TAG: latest          # Define the tag for your base image
  QUAY: quay.io/myorg       # Define the Quay registry URL (or your specific registry)

jobs:
  build:
    runs-on: windows-latest  # Using a Windows runner to execute PowerShell scripts

    steps:
      # Step 1: Checkout the repository
      - name: Checkout repository
        uses: actions/checkout@v2

      # Step 2: Set up Docker
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # Step 3: Log in to GitHub Container Registry using the GitHub Token
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Step 4: Install required tools like PowerShell (optional if on Windows runner)
      - name: Install PowerShell
        shell: pwsh
        run: |
          Install-Module -Name Pester -Force -SkipPublisherCheck -Scope CurrentUser

      # Step 5: Prepare the build directories
      - name: Prepare build directories
        shell: pwsh
        run: |
          Write-Output "[INFO] Setting up build directories"
          if (Test-Path .\build\bin) { Remove-Item .\build\bin -Recurse -Force }
          if (Test-Path .\build\nupkg) { Remove-Item .\build\nupkg -Recurse -Force }
          New-Item -Path ".\build\nupkg" -ItemType "directory" -Force
          New-Item -Path ".\build\bin" -ItemType "directory" -Force

      # Step 6: Gather manifest files
      - name: Gather manifest files
        shell: pwsh
        run: |
          Write-Output "[INFO] Gathering manifests..."
          $files = Get-ChildItem -Path ".\${env:BASE_IMAGE}" -Recurse -File -Include *manifest.json
          $content = @()
          For ($i = 0; $i -lt $files.Count; $i++) {
              $content += $($files[$i] | Get-Content -Raw | ConvertFrom-Json | ConvertTo-Hashtable)
          }
          $packages = @{}
          For ($i = 0; $i -lt $content.Count; $i++) {
              $keys = $content[$i].Keys -as [string[]]
              For ($n = 0; $n -lt $keys.Count; $n++) {
                  $value = $content[$i].$($keys[$n])
                  If (!$packages.ContainsKey($keys[$n])) {
                      $packages.Add($keys[$n], $value)
                  }
                  ElseIf ($packages.$($keys[$n]).version -lt $value.version) {
                      $packages.$($keys[$n]) = $value
                  }
                  ElseIf (($packages.$($keys[$n]).version -eq $value.version) -and (($packages.$($keys[$n]).build -lt $value.build -and $packages.$($keys[$n]).build -ne 'latest') -or $value.build -eq 'latest')) {
                      $packages.$($keys[$n]) = $value
                  }
              }
          }
          $packages | ConvertTo-Json | Out-File -FilePath './manifest.json' -NoNewline -Force

      # Step 7: Fetch NuGet Packages and extract them
      - name: Fetch and Extract NuGet Packages
        shell: pwsh
        run: |
          Write-Output "[INFO] Fetching NuGet Packages..."
          $package_version = ""
          $package_build = ""
          $keys = $packages.Keys -as [string[]]
          For ($i = 0; $i -lt $keys.Count; $i++) {
              $name = $packages.$($keys[$i]).name
              if($name -eq "PACKAGE") { 
                  $package_version = $packages[$keys[$i]].version
                  $package_build = $packages[$keys[$i]].build
                  Write-Output "package version $($package_version)"
                  continue
              }
              # Fetch subpackages list
              $myUri = "https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json"
              Write-Output $myUri
              $content = $(Invoke-WebRequest $myUri -Headers @{Authorization = "Bearer $env:GITHUB_TOKEN"}).content
              $links = $(Invoke-WebRequest $myUri -Headers @{Authorization = "Bearer $env:GITHUB_TOKEN"}).links -as [array]
              $version = $packages[$keys[$i]].version
              
              If ($links[0].href = '../') {
                  $links = $links[1..$($links.Count)]
              }
              Write-Output $version
              $buildlist = @()
              For ($n = 0; $n -lt $links.Count; $n++) {
                  $build = $packages.$($keys[$i]).build
                  If ($build -ne "latest") {
                      Write-Output "THIS IS NOT THE LATEST"
                      Write-Output "$version.$build"
                      $TempLinks = $links[$n].href
                      Write-Output "$TempLinks"
                      If ($links[$n].href -like "*$version.$build-*") {
                          $myUri = "https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json"
                          Write-Output "Downloading $myUri..."
                          $myFile = ".\build\nupkg\temp${n}.zip"
                          Invoke-WebRequest -Uri $myUri -OutFile $myFile -Headers @{Authorization = "Bearer $env:GITHUB_TOKEN"}
                          Expand-Archive -Path $myFile .\build\nupkg\ -Force
                          $name = [string]$packages.$($keys[$i]).name
                          New-Item -ItemType "directory" -Path ".\build\nupkg\" -Name $name -Force
                          New-Item -ItemType "directory" -Path ".\build\bin\" -Name $name -Force
                          Expand-Archive $myFile ".\build\nupkg\$name\" -Force
                          Get-ChildItem -Path ".\build\nupkg\$name\" -Filter *.dll -Recurse | Move-Item -Destination ".\build\bin\$name\" -Force
                          Get-ChildItem -Path ".\build\nupkg\$name\" -Filter *.deps.json -Recurse | Move-Item -Destination ".\build\bin\$name\" -Force
                          Get-ChildItem -Path ".\build\nupkg\$name\" -Filter *.pdb -Recurse | Move-Item -Destination ".\build\bin\$name\" -Force
                          Get-ChildItem -Path ".\build\bin\$name\" | Write-Output
                      }
                  }
              }
              If ($packages.$($keys[$i]).build -eq "latest") {
                  $lastbuild = $($buildlist | Sort-Object -Descending)[0]
                  For ($n = 0; $n -lt $links.Count; $n++) {
                      If ($links[$n].href -like "*.$version.$lastbuild-*") {
                          $myUri = "https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json"
                          Write-Output "Downloading $myUri..."
                          $myFile = ".\build\nupkg\temp${n}.zip"
                          Invoke-WebRequest -Uri $myUri -OutFile $myFile -Headers @{Authorization = "Bearer $env:GITHUB_TOKEN"}
                          $name = [string]$packages.$($keys[$i]).name
                          New-Item -ItemType "directory" -Path ".\build\nupkg\" -Name $name -Force
                          New-Item -ItemType "directory" -Path ".\build\bin\" -Name $name -Force
                          Expand-Archive $myFile ".\build\nupkg\$name\" -Force
                          Get-ChildItem -Path ".\build\nupkg\$name\" -Filter *.dll -Recurse | Move-Item -Destination ".\build\bin\$name\" -Force
                          Get-ChildItem -Path ".\build\nupkg\$name\" -Filter *.deps.json -Recurse | Move-Item -Destination ".\build\bin\$name\" -Force
                          Get-ChildItem -Path ".\build\nupkg\$name\" -Filter *.pdb -Recurse | Move-Item -Destination ".\build\bin\$name\" -Force
                          Get-ChildItem -Path ".\build\bin\$name\" | Write-Output
                      }
                  }
              }
          }

      # Step 8: Build and Push Docker Image
      - name: Build and Publish Docker Image
        shell: pwsh
        run: |
          Write-Output "[INFO] Creating & Publishing Docker Image for ${env:QUAY}/${env:BASE_IMAGE}-base:ext-${env:BASE_TAG}"
          docker build --pull . -f .\${env:BASE_IMAGE}\Dockerfile -t ${env:QUAY}/${env:BASE_IMAGE}-base:ext-${env:BASE_TAG}-$($package_version) --no-cache --build-arg QUAY=${env:QUAY} --build-arg BASE_IMAGE=${env:BASE_IMAGE}-base --build-arg BASE_TAG=${env:BASE_TAG}
          docker push ${env:QUAY}/${env:BASE_IMAGE}-base:ext-${env:BASE_TAG}-$($package_version)
          docker tag ${env:QUAY}/${env:BASE_IMAGE}-base:ext-${env:BASE_TAG}-$($package_version) ${env:QUAY}/${env:BASE_IMAGE}-base:latest
          docker push ${env:QUAY}/${env:BASE_IMAGE}-base:latest

      # Step 9: Clean up build directories
      - name: Clean up build directories
        shell: pwsh
        run: |
          if (Test-Path .\build) { Remove-Item .\build -Recurse -Force }

      # Step 10: Output Version
      - name: Output Version
        run: |
          Write-Host "${{ secrets.Version }}"
